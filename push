#!/bin/sh

self=$0
env=
user=${user:-root}
repo=$(basename $(dirname $(readlink -f $self)))
run=run.sh
dest=/tmp/$repo
systems='void alpine'

die() {
  printf "$@" >&2
  exit 64
}

validate() {
  local var val support supported
  for var; do
    eval val=\"\$$var\"
    [ -n "$val" ] || die 'no %s in %s\n' $var $env

    eval supported=\"\$${var}s\"
    if [ "$supported" ]; then
      for support in $supported; do
        [ "$val" != "$support" ] || continue 2
      done
      die '%s=%s not supported\n' $var "$val"
    fi
  done
}

parse() {
  [ $# -eq 2 -o $# -eq 3 ] || die '%s: <rules> <env> [roles]\n' $self

  rules=$(readlink -f $1)
  [ -d $rules ] || die 'no rules in %s\n' $rules

  env=$(readlink -f $2)
  . $env

  validate host system roles
  [ -n "$port" ] || port=22

  [ $# -ne 3 ] || roles="$3"
}

remote() {
  [ $host != localhost ]
}

mkrun() {
  cat <<EOF > $run
#!/bin/sh
$(sed 's/^_/export _/' $env)

role() {
  \${1}_role || {
    printf '%s failed\n' \$1 >&2
    exit 1
  }
}
EOF

  cat bin/*.sh $rules/roles/*.sh $rules/handlers/*.sh >> $run

  printf 'role %s\n' $roles >> $run
  chmod 700 $run
}

sync() {
  local d
  for d in $rules/templates $(dirname $env)/files; do
    rm -rf $(basename $d)
    [ -d $d ] && cp -r $d .
  done

  remote || return 0
  (
    cd ..
    tar cpf - $repo/$run $repo/templates $repo/files \
      | ssh -p $port $user@$host "tar xpf - -C $(dirname $dest)"
  )
}

execrun() {
  if remote; then
    ssh -p $port $user@$host $dest/$run
  else
    ./$run
  fi
}

parse "$@" && mkrun && sync && execrun
rm -f $run
